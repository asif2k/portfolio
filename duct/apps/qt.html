<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <title>finally</title>
  <script src="../finally.js"></script>  
</head>

<body>
  <canvas id="canv" width="800" height="800" style="width:1400px"></canvas>

  <script>    
    var qt = fin.define(function (proto) {

      proto.init_root = function (minx, miny, maxx, maxy) {
        this.aclloc_node(minx, miny, maxx, maxy, 0);
      };

      proto.aclloc_node = function (minx, miny, maxx, maxy, level) {
        var index = this.ii;
        this.ii += this.node_size;

        this.imem[index] = 1;
        this.imem[index + 1] = level;


        var bi = this.if;
        this.if += 4;
        this.imem[index + 2] = bi;
        this.imem[index + 3] = 0;
        this.fmem[bi] = minx;
        this.fmem[bi + 1] = miny;
        this.fmem[bi + 2] = maxx;
        this.fmem[bi + 3] = maxy;

        this.max_level = Math.max(this.max_level, level);
        this.imem[index + (this.node_size - 1)] = 78787878;

        this.nodes_count++;
        return index;
      };

      var work_stack = new Array(1024);
      var nchildern = [0, 0, 0, 0];
      var _aparams = [
        [0, 0, 0.5, 0.5],
        [0.5, 0, 1, 0.5],
        [0, 0.5, 0.5, 1],
        [0.5, 0.5, 1, 1]
      ];
      proto.add = function (x, y) {
        var imem = this.imem;
        var fmem = this.fmem;
        var aparams = _aparams, ap = null;
        var pi, bi;
        var nc = nchildern;
        var st = work_stack;

        var index, ni = 0;
        var op, si, ci, sw, sh, level, cc, nop, minx, miny, maxx, maxy;


        var oind = this.objects_in_node;
        var node_size = this.node_size;




        index = 0;
        si = 0;

        // alloc object
        op = this.ii;
        pi = this.if;
        this.if += 2;
        this.ii += this.object_size;
        this.objects_count++;
        imem[op] = pi;
        imem[op + (this.object_size - 1)] = 676767676;

        fmem[pi] = x;
        fmem[pi + 1] = y;




        st[si++] = -1;


        do {
          if (imem[index] === 2) {
            ci = 0;

            while (ci < 4) {
              cc = imem[index + (4 + ci)];
              bi = imem[cc + 2];
              if (x >= fmem[bi] && x < fmem[bi + 2]) {
                if (y >= fmem[bi + 1] && y < fmem[bi + 3]) {
                  st[si++] = cc;
                  break;
                }
              }
              ci++;
            }
          }
          else {
            ni = imem[index + 3];

            if (ni >= oind) {

              bi = imem[index + 2];




              minx = fmem[bi];
              miny = fmem[bi + 1];

              maxx = fmem[bi + 2];
              maxy = fmem[bi + 3];




              sw = (fmem[bi + 2] - minx) * 0.5;
              sh = (fmem[bi + 3] - miny) * 0.5;
              level = imem[index + 1] + 1;


              ci = -1;
              // alloc 4 child nodes
              /*
              while (++ci < 4) {            
                ap = aparams[ci];            
                ni = this.aclloc_node(
                  minx + (sw * ap[0]),
                  miny + (sh * ap[1]),
                  minx + (sw * ap[2]),
                  miny + (sh * ap[3]),
                  level
                );
                nc[ci] = ni;
              }
              */

              nc[0] = this.aclloc_node(minx, miny, minx + sw, miny + sh, level);
              nc[1] = this.aclloc_node(minx + sw, miny, maxx, miny + sh, level);
              nc[2] = this.aclloc_node(minx, miny + sh, minx + sw, maxy, level);
              nc[3] = this.aclloc_node(minx + sw, miny + sh, maxx, maxy, level);


              //console.log(nc.join()); return op;






              //relocate existing objects into new node
              ni = -1;
              while (++ni < oind) {
                nop = imem[index + 4 + ni];
                pi = imem[nop];
                x = fmem[pi];
                y = fmem[pi + 1];
                ci = 0;
                while (ci < 4) {
                  cc = nc[ci];
                  bi = imem[cc + 2];
                  if (x >= fmem[bi] && x < fmem[bi + 2]) {
                    if (y >= fmem[bi + 1] && y < fmem[bi + 3]) {
                      imem[cc + (4 + imem[cc + 3])] = nop;
                      imem[cc + 3] += 1;
                      imem[nop + 1] = cc;
                      break;
                    }
                  }
                  ci++;
                }
              }



              imem[index + 4] = nc[0];
              imem[index + 5] = nc[1];
              imem[index + 6] = nc[2];
              imem[index + 7] = nc[3];

              imem[index + 3] = 5666666;
              imem[index] = 2;


              //relocate current object into new node
              pi = imem[op];
              x = fmem[pi];
              y = fmem[pi + 1];

              ci = 0;
              while (ci < 4) {
                cc = nc[ci];
                bi = imem[cc + 2];
                if (x >= fmem[bi] && x < fmem[bi + 2]) {
                  if (y >= fmem[bi + 1] && y < fmem[bi + 3]) {
                    st[si++] = cc;
                    ci = 4;
                  }
                }
                ci++;
              }


            }
            else {
              imem[index + 4 + imem[index + 3]] = op;
              imem[index + 3] += 1;
              imem[op + 1] = index;

              return op;
            }
          }



          index = st[--si];
        } while (index > -1);




      }

      return function qt(max_nodes, objects_in_node, object_size, max_objects) {
        max_nodes = max_nodes || 9810609;
        max_objects = max_objects || 8806040

        this.objects_in_node = objects_in_node || 4;
        this.objects_in_node = Math.max(4, this.objects_in_node);

        this.node_size = 9;

        this.node_size += (this.objects_in_node - 4);

        this.object_size = object_size || 4;
        this.object_size = Math.max(4, this.object_size);

        this.max_level = 0;
        this.nodes_count = 0;
        this.objects_count = 0;


        this.ii = 0;
        this.if = 0;

        this.imem = new Uint32Array((max_nodes * this.node_size) + (max_objects * this.object_size));
        this.fmem = new Float32Array((max_nodes * 4) + (max_objects * 2));

      }

    });


    qt = fin.define(function (proto) {

      proto.init_root = function (minx, miny, maxx, maxy) {
        this.aclloc_node(minx, miny, maxx, maxy, 0);
      };

      proto.activate_node = function (index) {

        this.imem[index + 1] = this.ii;
        this.ii += this.node_size;
        index = this.imem[index + 1];
        this.imem[index] = 0;
        this.imem[index + (this.node_size - 1)] = 78787878;
        //this.imem[index + 1] = level;
        //this.imem[index + 2] = 0;
        return index;

      };

      proto.aclloc_node = function (minx, miny, maxx, maxy, level) {
        var index = this.ii;
        this.ii += 2;
        var bi = this.if;
        this.if += 4;
        this.imem[index] = bi;
        this.imem[index + 1] = 0;
        this.max_level = Math.max(this.max_level, level);
        this.fmem[bi] = minx;
        this.fmem[bi + 1] = miny;
        this.fmem[bi + 2] = maxx;
        this.fmem[bi + 3] = maxy;
        this.nodes_count++;
        return index;
      };

      var work_stack = new Uint32Array(1024);
      var nchildern = [0, 0, 0, 0];
      var _aparams = [
        [0, 0, 0.5, 0.5],
        [0.5, 0, 1, 0.5],
        [0, 0.5, 0.5, 1],
        [0.5, 0.5, 1, 1]
      ];
      proto.add = function (x, y) {
        var imem = this.imem;
        var fmem = this.fmem;
        var aparams = _aparams, ap = null;
        var pi, bi, iter = 0;
        var nc = nchildern;
        var st = work_stack;

        var id, pn = 0, ni = 0;
        var op, oop, si, ci, sw, sh, level, cc, nop, minx, miny, maxx, maxy;


        var oind = this.objects_in_node;
        var node_size = this.node_size;






        // alloc object
        op = this.ii;
        pi = this.if;
        this.if += 2;
        this.ii += this.object_size;
        this.objects_count++;
        imem[op] = pi;
        imem[op + (this.object_size - 1)] = 676767676;

        fmem[pi] = x;
        fmem[pi + 1] = y;


        oop = op;


        id = 0;
        si = 0;
        st[si++] = 0;
        st[si++] = 0;

       

        do {
      
          bi = imem[id];
          minx = fmem[bi]; miny = fmem[bi + 1];
          maxx = fmem[bi + 2]; maxy = fmem[bi + 3];

          pi = imem[op];
          x = fmem[pi];
          y = fmem[pi + 1];


          if (x < maxx && minx <= x && y < maxy && miny <= y) {
            pn = imem[id + 1];
            if (pn === 0) {
              pn = this.activate_node(id);
            }

            ni = imem[pn];
            if (ni === 11111111) {
              st[si++] = op;
              st[si++] = imem[pn + 1];
              st[si++] = op;
              st[si++] = imem[pn + 2];
              st[si++] = op;
              st[si++] = imem[pn + 3];
              st[si++] = op;
              st[si++] = imem[pn + 4];
            }
            else if (ni >= oind) {
              sw = (maxx - minx) * 0.5;
              sh = (maxy - miny) * 0.5;

              nc[0] = this.aclloc_node(minx, miny, minx + sw, miny + sh);
              nc[1] = this.aclloc_node(minx + sw, miny, maxx, miny + sh);
              nc[2] = this.aclloc_node(minx, miny + sh, minx + sw, maxy);
              nc[3] = this.aclloc_node(minx + sw, miny + sh, maxx, maxy);


              ci = -1;
              while (++ci < 4) {
                st[si++] = op;
                st[si++] = nc[ci];
                ni = -1;
                while (++ni < oind) {
                  st[si++] = imem[pn + 1 + ni];
                  st[si++] = nc[ci];
                }
              }
              imem[pn] = 11111111;
              imem[pn + 1] = nc[0];
              imem[pn + 2] = nc[1];
              imem[pn + 3] = nc[2];
              imem[pn + 4] = nc[3];
            }
            else {
              imem[pn + 1 + ni] = op;
              imem[pn] = ni + 1;
              //console.log(op, id+':'+pn);
              //return op;
              if (oop === op) return;
            }

          }
          /*
          if (x >= minx && x < maxx) {
            if (y >= miny && y < maxy) {
              


            }
          }
          */

          iter++;

          this.msi = Math.max(this.msi, si);
        

          id = st[--si];
          op = st[--si];
        } while (si > 0);

        this.miter = Math.max(this.miter, iter);


      }

      proto.get_objects = function (minx, miny, maxx, maxy, dest) {
        var imem = this.imem;
        var fmem = this.fmem;
        var bi;
        var st = work_stack;
        var index, ni = 0;

        var si = 0, di = 0;
        st[si++] = 90191919;

        do {
          bi = imem[index + 2];
          if ((minx <= fmem[bi + 2] && fmem[bi] <= maxx && miny <= fmem[bi + 3] && fmem[bi + 1] <= maxy)) {
            if (imem[index] === 2) {
              st[si++] = imem[index + 4];
              st[si++] = imem[index + 5];
              st[si++] = imem[index + 6];
              st[si++] = imem[index + 7];
            }
            else {
              ni = imem[index + 3];
              while (--ni > -1) {
                dest[di++] = imem[index + 4 + ni];
              }
            }
          }
          index = st[--si];
        } while (index !== 90191919);



        return di;
      }


      return function qt(max_nodes, objects_in_node, object_size, max_objects) {
        max_nodes = max_nodes || 16883537;
        max_objects = max_objects || 8806040

        this.objects_in_node = objects_in_node || 4;
        this.objects_in_node = Math.max(4, this.objects_in_node);

        this.node_size = 6;

        this.node_size += (this.objects_in_node - 4);

        this.object_size = object_size || 2;
        this.object_size = Math.max(2, this.object_size);

        this.max_level = 0;
        this.nodes_count = 0;
        this.objects_count = 0;
        this.msi = 0;

        this.ii = 0;
        this.if = 0;
        this.miter = 0;
        this.imem = new Uint32Array((max_nodes * this.node_size) + (max_objects * this.object_size));
        this.fmem = new Float32Array((max_nodes * 4) + (max_objects * 2));

      }

    });



    qt = fin.define(function (proto) {

      proto.init_root = function (minx, miny, maxx, maxy) {
        this.aclloc_node(minx, miny, maxx, maxy, 0);
      };



      proto.check_inbounds = function (bi, x, y) {
        if (x >= this.fmem[bi] && x < this.fmem[bi + 2]) {
          if (y >= this.fmem[bi + 1] && y < this.fmem[bi + 3]) {
            return true;
          }
        }
        return false;
      }

      proto.aclloc_node = function (minx, miny, maxx, maxy, level) {

        this.nodes_max_level = Math.max(this.nodes_max_level, level);
        var id = this.ii;
        this.ii += 4;



        var bi = this.if;
        this.if += 4;
        this.imem[id] = bi;
        this.imem[id + 1] = level;
        this.imem[id + 2] = 0;
        this.imem[id + 3] = 0;
        this.fmem[bi] = minx;
        this.fmem[bi + 1] = miny;
        this.fmem[bi + 2] = maxx;
        this.fmem[bi + 3] = maxy;
        this.nodes_count++;
        return id;
      };

      var work_stack = new Uint32Array(1024);
      var nchildern = [0, 0, 0, 0];


      proto.create_object = function (x, y) {
        var id = this.ii;
        this.ii += 4;
        var pi = this.if;
        this.if += 2;
        this.imem[id] = pi;
        this.fmem[pi] = x;
        this.fmem[pi + 1] = y;
        this.imem[id + 1] = 0;
        this.imem[id + 2] = 0;
        this.imem[id + 3] = 999999999;
        this.objects_count++;

        return id;

      }
      proto.link_object = function (id, link) {
        if (link > 0) this.imem[link + 2] = id;
        this.imem[id + 1] = link;
        return id;
      }
      proto.unlink_object = function (id) {
        var prev = this.imem[id + 1];
        var next = this.imem[id + 2];
        if (prev > 0) {
          this.imem[prev + 2] = this.imem[id + 2];
        }
        if (next > 0) {
          this.imem[next + 1] = prev;
        }
      }

      proto.link_object_node = function (nid, oid) {
        this.imem[nid + 3] = this.link_object(oid, this.imem[nid + 3]);
        this.imem[nid + 2]++;
      }
      proto.add = function (x, y) {
        var imem = this.imem;
        var fmem = this.fmem;
        var pi, bi, iter = 0;
        var nc = nchildern;
        var st = work_stack;

        var id, pn = 0, ni = 0, olink, onext, oprev;
        var op, oop, si, ci, sw, sh, level, cc, nop, minx, miny, maxx, maxy;

        var oind = this.objects_in_node;

        si = 0;
        st[si++] = 0;

        op = this.create_object(x, y);
        id = 0;

        do {

          if (imem[id + 2] === 111111111) {
            pn = imem[id + 3];

            if (this.check_inbounds(imem[imem[pn]], x, y)) {
              st[si++] = imem[pn];
            }
            else if (this.check_inbounds(imem[imem[pn+1]], x, y)) {
              st[si++] = imem[pn+1];
            }
            else if (this.check_inbounds(imem[imem[pn + 2]], x, y)) {
              st[si++] = imem[pn + 2];
            }
            else if (this.check_inbounds(imem[imem[pn + 3]], x, y)) {
              st[si++] = imem[pn + 3];
            }

          }
          else if (this.check_inbounds(imem[id], x, y)) {
            if (imem[id + 2] >= oind && imem[id + 1] < this.max_level) {
              bi = imem[id];
              minx = fmem[bi]; miny = fmem[bi + 1];
              maxx = fmem[bi + 2]; maxy = fmem[bi + 3];


              sw = (maxx - minx) * 0.5;
              sh = (maxy - miny) * 0.5;
              level = imem[id + 1] + 1;

              pn = this.ii;
              this.ii += 4;


              imem[pn] = this.aclloc_node(minx, miny, minx + sw, miny + sh, level);
              imem[pn + 1] = this.aclloc_node(minx + sw, miny, maxx, miny + sh, level);
              imem[pn + 2] = this.aclloc_node(minx, miny + sh, minx + sw, maxy, level);
              imem[pn + 3] = this.aclloc_node(minx + sw, miny + sh, maxx, maxy, level);


              imem[id + 2] = 111111111
              olink = imem[id + 3];
              imem[id + 3] = pn;

              
              while (olink >0 ) {
                oprev = imem[olink + 1];
                pi = imem[olink];
                ci = -1;
                while (++ci < 4) {
                  cc = imem[pn + ci];
                  if (this.check_inbounds(imem[cc], fmem[pi], fmem[pi + 1])) {
                    this.link_object_node(cc, olink);
                    break;
                  }
                }
                olink = oprev;
              }

              ci = -1;
              while (++ci < 4) {
                cc = imem[pn + ci];
                if (this.check_inbounds(imem[cc], x, y)) {
                  this.link_object_node(cc, op);
                  return op;
                }
              }
            }
            else {
              this.link_object_node(id, op);
              return op;
            }
          }


          iter++;
          this.msi = Math.max(this.msi, si);
          this.miter = Math.max(this.miter, iter);

          id = st[--si];
        } while (si > 0);

      }




      return function qt(max_nodes, objects_in_node, object_size, max_objects) {
        max_nodes = max_nodes || 395633;
        max_objects = max_objects || 106040

        this.objects_in_node = objects_in_node || 8;
        this.objects_in_node = Math.max(4, this.objects_in_node);

        this.node_size = 5;

        this.node_size += (this.objects_in_node - 4);

        this.object_size = object_size || 2;
        this.object_size = Math.max(2, this.object_size);

        this.max_level = 19;
        this.nodes_max_level = 0;
        this.nodes_count = 0;
        this.active_nodes_count = 0;
        this.objects_count = 0;
        this.msi = 0;

        this.ii = 0;
        this.if = 0;
        this.miter = 0;
        this.imem = new Uint32Array((max_nodes * (this.node_size)) + (max_objects * this.object_size));
        this.fmem = new Float32Array((max_nodes * 6) + (max_objects * 2));

      }
    });
    var qq = new qt();
    console.log(qq);

    qq.init_root(0, 0, 800, 800);
    var time_start = Date.now();
    for (var i = 0; i < 1150000; i++) {
      qq.add((Math.random() * 800), (Math.random() * 800));
    }
    console.log(`${(Date.now() - time_start)} ms / nodes ${qq.nodes_count}  miter ${qq.miter} |`);

    var canv = document.getElementById("canv");
    var ctx = canv.getContext("2d");


    var work_stack = new Uint32Array(1024);
    function draw_qt() {
      var st = work_stack;
      var si = 0;
      var id = 0, pn = 0,bi=0;
      var imem = qq.imem;
      var fmem = qq.fmem;
      st[si++] = 0;
      do {

        if (imem[id + 2] === 111111111) {
          pn = imem[id + 3];
          st[si++] = imem[pn];
          st[si++] = imem[pn + 1];
          st[si++] = imem[pn + 2];
          st[si++] = imem[pn + 3];
        }
        else  {
          bi = imem[id];
          ctx.strokeStyle = "black";
          ctx.strokeRect(fmem[bi], fmem[bi + 1], fmem[bi + 2] - fmem[bi], fmem[bi + 3] - fmem[bi + 1]);
        }
        id = st[--si];
      } while (si > 0);
    }

   // draw_qt();



  </script>


  
</body>
</html>